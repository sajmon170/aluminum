
Current problems:
- The UI is currently concerned with the logic - each incoming message gets
  marked as "Me"
- There is no proper translation between Message::Send and DisplayMessage
    => Translate Message::Send to DisplayMessage in the connection manager thread
    => OR: Provide the sent message and receiver data to the UI thread
    => OR: Use a conversion function
    => OR: Make only one message type
    - INEFFECTIVE - there's no point to send the author with each message
- The relay server is currently simulating a client - this should not be happening
- Two clients need to connect to each other through the relay. You don't need to implement
  hole punching right now.
- messages typed into the UI don't get sent to the other party

Idea: maybe separate Message into two layers: transport and messaging.
The messaging layer doesn't need to concern itself with the Bye and Ack messages.
There would be a new message type
Message::ApplicationData(AppData)
- Is there a need for a Bye message if you can just disconnect?
- => A bye message acts as a planned disconnect

Relay entry
If the database contains a relay entry then the database format between the server and user don't match anymore

Compared to a user, the relay entry:
- contains an IP address
- doesn't contain any user information other than the Ed25519 identity key

* TODO Base features
- [X] Streamline CancellationToken argument types
- [X] Add tracing support
- [X] Allow sending messages
- [X] Argument parsing
- [X] Integrate database into the app
- [X] Modify the program to contain a relay entry
- [X] Streamline the message type
- [X] Implement a message database
- [X] Allow connecting to another client through relay
- [X] Separate ingress and egress message codecs 
- [X] Implement QUIC
- [X] Implement hole punching
- [X] Allow selecting another user to chat with

Good luck, keep yourself hydrated with monster energy...

* TODO Extended features
- [-] UI features
  - [X] Allow creating multiple views
  - [X] Tab selection
  - [ ] Loading friends into database
  - [X] Selecting friends
  - [ ] Message notifications
  - [X] Prettify tabs
- [ ] Extended messages
  - [ ] Architecture
    - [ ] replace the paragraph with a bottom-to-top list 
    - [ ] wrap the list inside a ScrollView
    - [ ] create a structured GenericMessage/ListItem struct
  - [ ] Add colors to name handles
  - [ ] Gray out the time
  - [ ] Each message in the database gets a sent/unsent status
  
- [X] Load message history for each peer
- [ ] Implement the database as a vector of Arc values
- [X] Handle connection errors
  - [X] Add a "connected" status bar to UI instead of panicking
  - [X] Fix crashing when sending a message to an offline host
  - [X] Fix crashing when the server is not online
- [X] Make the register() RPC safe
  - [X] Compare the received Ed25519 key to the the X25519 Noise handshake key returned from the handshake function
- [ ] Replace the event management framework with callbacks
- [ ] Implement RPCs with Tower Services
- [ ] Streamline the Result return type (reduce dynamic dispatch)
- [X] Prettify the code with rustfmt-unstable

* TODO bugfixing
- [X] Fix connection timeout
- [X] Fix UI issues
  - [X] Fix strings getting saved with a newline into the database
  - [X] Fix names display - currently all messages (including our own) get rendered with peer's name
  - [X] Scroll the UI to bottom when a new message gets sent

* Sending messages
- Messages originate from the GUI
- they propagate to... where?

I can access the ConnManager struct through a handle - that handle is communicating with an mpsc


Another approach: What exactly does the ConnManager handle?
- connecting with the relay
- connecting with users listed by the relay
- managing each Noise stream between each user and the relay
  => Only this struct knows about the stream - other structs don't concern themselves with that.
  => ConnManager awaits data on MPSC channels and sends them through the Noise stream

Q: can't the app component just send through the stream directly without ConnManager? As in - the ConnManager makes a stream and returns it?

The AppController is combined with AppUI - it should run on a separate task from everything else and contain as little async logic as possible.

* Design notes
- It's hard to pass the terminal between threads
- EventHandler is necessary for accumulating the events into a stream of a singular Event type that can then be handled in a uniform way/unit tested
